# 0.面向对象

1. 变量私有的叫字段，公有的是属性
2. 封装
   1. 良好的封装能够减少耦合
   2. 良好的封装能够减少耦合
   3. 类具有清晰的对外接口

---

1. 对象继承代表了一种 ‘is-a’ 的关系，如果两个对象A和B，可以描述为‘B是A’，则表明B可以继承A
2. 当两个类之间是‘has-a’的关系时，表示某个角色具有某一项责任，此时不合适用继承。比如人有两只手，手不能继承人；再比如飞机场有飞机，这飞机也不能去继承飞机场。

---

1. 多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。

---

1. 接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。

   一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。

   声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。

2. 抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现，一个类只能继承一个抽象类，但可实现多个接口等等。

3. 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。

4. 如果行为跨越不同类的对象，可使用接口

5. 从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确认，预先定义

6. 通过重构改善既有代码的设计

7. 事实上，只有小猫的时候，你就去设计一个动物类，这就极有可能会成为过度设计了。所以说抽象类往往都是通过重构得来的

8. 抽象类是自底而上抽象出来的，而接口则是自顶向下设计出来的

---

# 1.简单工厂模式

## 1.面向对象的好处

1. 可维护
2. 可复用
3. 可扩展
4. 灵活性高

通过封装、继承和多态降低程序之间的耦合度，使用设计模式达到上面四个点

---

## 2.业务的封装

添加新业务时，应尽量减少对现有业务逻辑的影响

---

## 3.简单工厂模式

![image-20230720170914297](images/image-20230720170914297.png)

---

## 4.UML类图

### 1.类

类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。

第二层是类的特性，通常就是字段和属性。

第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。”

![image-20230720171228362](images/image-20230720171228362.png)

---

### 2.接口

与类图的区别主要是顶端有<<interface>>显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法

![image-20230720171248286](images/image-20230720171248286.png)

![image-20230720171257886](images/image-20230720171257886.png)

---

### 3.继承关系

继承关系用空心三角形+实线来表示

![image-20230720171346935](images/image-20230720171346935.png)

---

### 4.接口实现

实现接口用空心三角形+虚线来表示

![image-20230720171433950](images/image-20230720171433950.png)

---

### 5.关联关系

当一个类‘知道’另一个类时，可以用关联（association）。关联关系用实线箭头来表示

![image-20230720171617579](images/image-20230720171617579.png)

![image-20230720171635014](images/image-20230720171635014.png)

---

### 6.聚合关系

聚合关系用空心的菱形+实线箭头来表示

![image-20230720171910093](images/image-20230720171910093.png)

![image-20230720171917156](images/image-20230720171917156.png)

---

### 7.合成关系

合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的

![image-20230720172512421](images/image-20230720172512421.png)

---

### 8.依赖关系

依赖关系（Dependency），用虚线箭头来表示

![image-20230720172556765](images/image-20230720172556765.png)

---

# 2.策略者模式

## 1.

面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类

---

## 2.策略模式代码

![undefined](images/Strategy_Pattern_in_UML.png)

```java
//StrategyExample test application

class StrategyExample {

    public static void main(String[] args) {

        Context context;

        // Three contexts following different strategies
        context = new Context(new FirstStrategy());
        context.execute();

        context = new Context(new SecondStrategy());
        context.execute();

        context = new Context(new ThirdStrategy());
        context.execute();

    }

}

// The classes that implement a concrete strategy should implement this

// The context class uses this to call the concrete strategy
interface Strategy {

    void execute();
    
}

// Implements the algorithm using the strategy interface
class FirstStrategy implements Strategy {

    public void execute() {
        System.out.println("Called FirstStrategy.execute()");
    }
    
}

class SecondStrategy implements Strategy {

    public void execute() {
        System.out.println("Called SecondStrategy.execute()");
    }
    
}

class ThirdStrategy implements Strategy {

    public void execute() {
        System.out.println("Called ThirdStrategy.execute()");
    }
    
}

// Configured with a ConcreteStrategy object and maintains a reference to a Strategy object
class Context {

    Strategy strategy;

    // Constructor
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void execute() {
        this.strategy.execute();
    }

}
```

---

## 3.与简单工厂模式结合

```java 
public class Context {
    private Strategy strategy;

    public Context(int i) {
        switch (i) {
            case 1 -> strategy = new FirstStrategy();
            case 2 -> strategy = new SecondStrategy();
        }
    }

    public void execute() {
        this.strategy.execute();
    }
}
```

结合后客户端就不需要认识对应的策略对象只需要传递对应的值即可，降低耦合度

---

# 3.单一职责原则

就一个类而言，应该仅有一个引起它变化的原因

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。

这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏

---

# 4.开放-封闭原则

开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改

这个原则其实是有两个特征，一个是说‘对于扩展是开放的（Open for extension）’，另一个是说‘对于更改是封闭的（Closed for modification）

